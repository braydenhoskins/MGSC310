### Auto data
#------------------------------------------------
# using Auto data
library(ISLR)
data("Auto")
auto
# scaling
####make variables similar scales
str(Auto)
Auto_scale <- scale(Auto[,1:7])
head(Auto)
head(Auto_scale)
fviz_nbclust(Auto_scaled,
kmeans,
method="wss") +
geom_vline(xintercept=3, linetype =2) +
labs(subtitle ="Elbow Method")
Auto_scaled <- scale(Auto[,1:7]) ###gets rid of origin and name and scales the values
#------------------------------------------------
### number of clusters?
#------------------------------------------------
# elbow method
fviz_nbclust(Auto_scaled,
kmeans,
method="wss") +
geom_vline(xintercept=3, linetype =2) +
labs(subtitle ="Elbow Method")
# Silhouette method
fviz_nbclust(Auto_scaled,
kmeans,
method="silhouette")
# Gap Statistic method
fviz_nbclust(Auto_scaled,
kmeans,
method="gap_stat",
nboot=100)
library("NbClust")
Nb_cl <- NbClust(Auto_Scaled,
diss = NULL,
distance = "eucladian")
Nb_cl <- NbClust(Auto_Scaled,
diss = NULL,
distance = "euclidean")
Nb_cl <- NbClust(Auto_Scaled,
diss = NULL,
distance = "eucledean")
Nb_cl <- NbClust(Auto_Scaled,
diss = NULL,
distance = "eucladean")
Nb_cl <- NbClust(Auto_Scaled,
diss = NULL,
distance = "euclidean",
min.nc = 2,
max.nc = 10,
method = "kmeans")
Auto_scaled <- scale(Auto[,1:7]) ###gets rid of origin and name and scales the values
Nb_cl <- NbClust(Auto_scaled,
diss = NULL,
distance = "euclidean",
min.nc = 2,
max.nc = 10,
method = "kmeans")
# try different clusters and compare the results
km2 <- kmeans(Auto_scale,2)
# try different clusters and compare the results
km2 <- kmeans(Auto_scaled,2)
remove(Auto_scale)
# try different clusters and compare the results
km2 <- kmeans(Auto_scaled,2)
km2 <- kmeans(Auto_scaled,2)
km3 <- kmeans(Auto_scaled,3)
km4 <- kmeans(Auto_scaled,4)
km5 <- kmeans(Auto_scaled,5)
km6 <- kmeans(Auto_scaled,6)
km7 <- kmeans(Auto_scaled,7)
# visualize the results
library(cowplot)
p1 <- fviz_cluster(km2,data = Auto_scaled) + theme_minimal() +
ggtitle("k=2")
p1
p1 <- fviz_cluster(km2,data = Auto_scaled) + theme_minimal() +
ggtitle("k=2")
p2 <- fviz_cluster(km3,data = Auto_scaled) + theme_minimal() +
ggtitle("k=3")
p3 <- fviz_cluster(km4,data = Auto_scaled) + theme_minimal() +
ggtitle("k=4")
p4 <- fviz_cluster(km5,data = Auto_scaled) + theme_minimal() +
ggtitle("k=5")
p5 <- fviz_cluster(km6,data = Auto_scaled) + theme_minimal() +
ggtitle("k=6")
p6 <- fviz_cluster(km7,data = Auto_scaled) + theme_minimal() +
ggtitle("k=7")
plot_grid(p1,p2,p3,p4,p5,p6,
labels = C("k2","k3","k4","k5","k6","k7"))
library(cowplot)
plot_grid(p1,p2,p3,p4,p5,p6)
# pick the best number of clusters
###nstart uses many iterations through kmeans to remove randomization of initial assignments
finalkm <- kmeans(Auto_scaled,3,nstart = 30)
fviz_cluster(finalkm,data = Auto_scaled)
fviz_cluster(finalkm)
fviz_cluster(finalkm,data = Auto_scaled)
# store the cluster information in the data frame
Auto$cluster <- as.factor(finalkm$cluster)
# use ggpairs to see if the clusters are meaningful
library(GGally)
ggpairs(Auto,1:5,mapping = aes(color = cluster,alpha = .5))
#------------------------------------------------
### PCA
#------------------------------------------------
# use the auto data set
data(Auto)
# run pca model
auto_pca <- prcomp(Auto)
# run pca model
auto_pca <- prcomp(Auto[,1:7])
# summary
summary(auto_pca)
# run pca model
auto_pca <- prcomp(Auto[,1:7],
center = TRUE,
scale = TRUE)
# summary
summary(auto_pca)
# how much variation each dimension captures
fviz_screeplot(auto_pca)
# Extract the results for variables
var <- get_pca_var(auto_pca)
# Contributions of variables to PC1
fviz_contrib(auto_pca,choice = "var",axes = 1,top = 10)
install.packages("devtools")
install.packages("devtools")
install_github("vqv/ggbiplot")
library(devtools)
install_github("vqv/ggbiplot")
#install.packages("devtools")
#library(devtools)
install_github("vqv/ggbiplot")
library(ggbiplot)
# ggbiplot to visualize the results
ggbiplot(auto_pca,ellipse = TRUE)
setwd("~/Desktop")
m.dat <- read.csv("New_Men_Match_Complete.csv")
w.dat <- read.csv("New_Women_Match_Complete.csv")
setwd("C:\\Users\\noahe\\desktop\\mgsc310")
#       Library Calls         #
#-----------------------------#
library(forcats)
library(tidyverse)
library(summarytools)
library(corrplot)
library(ggplot2)
library(glmnet)
library(glmnetUtils)
library(randomForest)
library(randomForestExplainer)
library(caret)
library(plotROC)
library(PRROC)
library(gmodels)
library(tree)
#------------------------------------#
#       Importing Data Set           #
#------------------------------------#
steam <- read.csv("steam.csv")
#---------------------------------------------#
#        Exploratory Data Analysis            #
#---------------------------------------------#
nrow(steam[!complete.cases(steam),])
# There are no rows with missing values
#---------------------------------------------#
#       Variable Engineering/Cleaning         #
#---------------------------------------------#
steam$price <- steam$price *1.28
# Turns the units into dollars
steam<- subset(steam, select = -c(appid,english,steamspy_tags,
name,release_date,
platforms,publisher,developer))
# Removing variables that are not useful
steam$genres <- do.call('rbind',strsplit(as.character(steam$genres), ';', fixed=TRUE))[,1]
steam$categories <- do.call('rbind',strsplit(as.character(steam$categories), ';', fixed=TRUE))[,1]
# Getting rid of all the ';' delimited variables and instead assigned them a single value for that column
steam$categories <- as.factor(steam$categories)
steam$genres <- as.factor(steam$genres)
# Making categories and genres as factored variables
steam <- steam[steam$average_playtime < 100000,]
steam <- steam[steam$price <50,]
steam <- steam[steam$average_playtime < 40000,]
steam <- steam[steam$negative_ratings < 2e+05,]
steam <- steam[steam$positive_ratings < 1e+06,]
# Removing outliers
steam$simple_categories <- fct_lump(steam$categories,n = 4)
# Creating a factored feature with only 4 options
unique(steam$simple_categories)
steam$categories <- ifelse(steam$categories == "Single-player","SinglePlayer",
ifelse(steam$categories == "Multi-player","Multi-Player",
ifelse(steam$categories == "Online Multi-Player","Multi-Player",
ifelse(steam$categories == "Local Multi-Player","Multi-Player",
ifelse(steam$categories == "MMO","MMO",
ifelse(steam$categories == "Co-op","Co-op",
ifelse(steam$categories == "Shared/Split Screen","Co-op",
ifelse(steam$categories == "Local Co-op","Co-op",
ifelse(steam$categories == "Online Co-op","Co-op",
ifelse(steam$categories == "Steam Cloud","Steam",
ifelse(steam$categories == "Steam Trading Cards","Steam",
ifelse(steam$categories == "Steam Leaderboards","Steam",
ifelse(steam$categories == "Steam Achievements","Steam","Other")))))))))))))
steam$categories <- as.factor(steam$categories)
unique(steam$categories)
# Another way of lumping together factors
steam$genres <- fct_lump(steam$genres,n = 5)
unique(steam$genres)
# Reducing the number of genres
#-----------------------------------------------#
#          Creating Predictor Variable          #
#-----------------------------------------------#
steam$successfulGame <- ifelse(steam$owners == "10000000-20000000",1,
ifelse(steam$owners == "20000000-50000000",1,
ifelse(steam$owners == "50000000-100000000",1,
ifelse(steam$owners == "100000000-200000000",1,
ifelse(steam$owners == "5000000-10000000",1,
ifelse(steam$owners == "2000000-5000000",1,
ifelse(steam$owners == "1000000-2000000",1,0)))))))
steam <- subset(steam, select = -c(owners,categories,positive_ratings,negative_ratings,
median_playtime))
steam$required_age <- as.factor(steam$required_age)
colnames(steam)
knitr::opts_chunk$set(echo = TRUE)
library(forcats)
library(tidyverse)
library(summarytools)
library(corrplot)
library(ggplot2)
library(glmnet)
library(glmnetUtils)
library(randomForest)
library(randomForestExplainer)
library(caret)
library(plotROC)
library(PRROC)
library(gmodels)
library(tree)
####cleaning the data
steam <- read.csv("steam.csv")
nrow(steam[!complete.cases(steam),])
steam$price <- steam$price *1.28
steam<- subset(steam, select = -c(appid,english,steamspy_tags,
name,release_date,
platforms,publisher,developer))
steam$genres <- do.call('rbind',strsplit(as.character(steam$genres), ';', fixed=TRUE))[,1]
steam$categories <- do.call('rbind',strsplit(as.character(steam$categories), ';', fixed=TRUE))[,1]
steam$categories <- as.factor(steam$categories)
steam$genres <- as.factor(steam$genres)
steam <- steam[steam$average_playtime < 100000,]
steam <- steam[steam$price <50,]
steam <- steam[steam$average_playtime < 40000,]
steam <- steam[steam$negative_ratings < 2e+05,]
steam <- steam[steam$positive_ratings < 1e+06,]
steam$simple_categories <- fct_lump(steam$categories,n = 4)
steam$categories <- ifelse(steam$categories == "Single-player","SinglePlayer",
ifelse(steam$categories == "Multi-player","Multi-Player",
ifelse(steam$categories == "Online Multi-Player","Multi-Player",
ifelse(steam$categories == "Local Multi-Player","Multi-Player",
ifelse(steam$categories == "MMO","MMO",
ifelse(steam$categories == "Co-op","Co-op",
ifelse(steam$categories == "Shared/Split Screen","Co-op",
ifelse(steam$categories == "Local Co-op","Co-op",
ifelse(steam$categories == "Online Co-op","Co-op",
ifelse(steam$categories == "Steam Cloud","Steam",
ifelse(steam$categories == "Steam Trading Cards","Steam",
ifelse(steam$categories == "Steam Leaderboards","Steam",
ifelse(steam$categories == "Steam Achievements","Steam","Other")))))))))))))
steam$categories <- as.factor(steam$categories)
steam$genres <- fct_lump(steam$genres,n = 5)
steam$successfulGame <- ifelse(steam$owners == "10000000-20000000",1,
ifelse(steam$owners == "20000000-50000000",1,
ifelse(steam$owners == "50000000-100000000",1,
ifelse(steam$owners == "100000000-200000000",1,
ifelse(steam$owners == "5000000-10000000",1,
ifelse(steam$owners == "2000000-5000000",1,
ifelse(steam$owners == "1000000-2000000",1,0)))))))
steam <- subset(steam, select = -c(owners,categories,positive_ratings,negative_ratings,
median_playtime))
steam$required_age <- as.factor(steam$required_age)
head(steam,5)
ggplot(steam,aes(x = price,y = average_playtime)) +
geom_point(aes(color = successfulGame)) +
labs(x = "Price of the Game (dollars)",y ="Average Playtime (hrs)",
title = "Average Playtime Plotted Against Price of Game")
ggplot(steam,aes(x = price,y = average_playtime)) +
geom_point(aes(color = factor(successfulGame)) +
labs(x = "Price of the Game (dollars)",y ="Average Playtime (hrs)",
title = "Average Playtime Plotted Against Price of Game")
ggplot(steam,aes(x = price,y = average_playtime)) +
geom_point(aes(color = as.factor(successfulGame)) +
labs(x = "Price of the Game (dollars)",y ="Average Playtime (hrs)",
title = "Average Playtime Plotted Against Price of Game")
ggplot(steam,aes(x = price,y = average_playtime)) +
geom_point(aes(color = factor(successfulGame))) +
labs(x = "Price of the Game (dollars)",y ="Average Playtime (hrs)",
title = "Average Playtime Plotted Against Price of Game")
ggplot(steam,aes(x = achievements,y = average_playtime)) + geom_point(aes(color = factor(successfulGame))+
geom_smooth() + labs(x = "Number of In-Game Achievements",y = "Average Playtime (hrs)",
title = "Plotted Achievements and Average Playtime")
ggplot(steam,aes(x = achievements,y = average_playtime)) + geom_point(aes(color = factor(successfulGame)))+
geom_smooth() + labs(x = "Number of In-Game Achievements",y = "Average Playtime (hrs)",
title = "Plotted Achievements and Average Playtime")
ggplot(steam,aes(x = achievements,y = average_playtime)) + geom_point(aes(color = successfulGame))+
geom_smooth() + labs(x = "Number of In-Game Achievements",y = "Average Playtime (hrs)",
title = "Plotted Achievements and Average Playtime")
ggplot(steam,aes(x = price,y = average_playtime)) +
geom_point(aes(color = successfulGame)) +
labs(x = "Price of the Game (dollars)",y ="Average Playtime (hrs)",
title = "Average Playtime Plotted Against Price of Game")
boxplot(steam$average_playtime~steam$required_age,
main = "Average Playtime by Required Age",xlab = "Required Age (years)",
ylab = "Average Playtime")
ggplot(steam,aes(x = genres,y = price)) + geom_boxplot() +
labs(title = "Boxplots of Price By Genre",x = "Genres",y = "Price (dollars)")
train_ROC <- ggplot(steam_train,aes(m = logit_preds,
d = successfulGame)) +
geom_roc(labelsize = 3.5,
cutoffs.at = c(.99,.9,.7,.6,.5,.4,.1,.01)) +
labs(title = "ROC Curve for Train Data",x = "False Positive Fraction",
y= "True Positive Fraction")
set.seed(2019)
train_index <- sample(1:nrow(steam),.75*nrow(steam),replace = FALSE)
steam_train <- steam[train_index,]
steam_test <- steam[-train_index,]
dim(steam_train)
dim(steam_test)
steam_logit <- glm(successfulGame~price+relevel(genres,ref = "Other") + required_age+
average_playtime,
data = steam_train,
family = "binomial")
summary(steam_logit)
exp(steam_logit$coefficients)
train_ROC <- ggplot(steam_train,aes(m = logit_preds,
d = successfulGame)) +
geom_roc(labelsize = 3.5,
cutoffs.at = c(.99,.9,.7,.6,.5,.4,.1,.01)) +
labs(title = "ROC Curve for Train Data",x = "False Positive Fraction",
y= "True Positive Fraction")
test_ROC <- ggplot(steam_test,aes(m = logit_preds,
d = successfulGame)) +
geom_roc(labelsize = 3.5,
cutoffs.at = c(.99,.9,.7,.6,.5,.4,.1,.01)) +
labs(title = "ROC Curve for Test Data",x = "False Positive Fraction",
y= "True Positive Fraction")
steam_train$pred_class <- ifelse(steam_train$logit_preds >.04,1,0)
set.seed(2019)
train_index <- sample(1:nrow(steam),.75*nrow(steam),replace = FALSE)
steam_train <- steam[train_index,]
steam_test <- steam[-train_index,]
####Used to find significant predictors
steam_logit <- glm(successfulGame~.,
data = steam_train,
family = "binomial")
####Now only significant predictors included
steam_logit <- glm(successfulGame~price+relevel(genres,ref = "Other") + required_age+
average_playtime,
data = steam_train,
family = "binomial")
summary(steam_logit)
exp(steam_logit$coefficients)
steam_train$logit_preds <- predict(steam_logit,type = "response")
steam_test$logit_preds <- predict(steam_logit,newdata = steam_test,
type = "response")
PRROC_obj_train <- roc.curve(scores.class0 = steam_train$logit_preds,
weights.class0=steam_train$successfulGame,
curve=TRUE)
plot(PRROC_obj_train)
PRROC_obj_test <- roc.curve(scores.class0 = steam_test$logit_preds,
weights.class0=steam_test$successfulGame,
curve=TRUE)
plot(PRROC_obj_test)
train_ROC <- ggplot(steam_train,aes(m = logit_preds,
d = successfulGame)) +
geom_roc(labelsize = 3.5,
cutoffs.at = c(.99,.9,.7,.6,.5,.4,.1,.01)) +
labs(title = "ROC Curve for Train Data",x = "False Positive Fraction",
y= "True Positive Fraction")
test_ROC <- ggplot(steam_test,aes(m = logit_preds,
d = successfulGame)) +
geom_roc(labelsize = 3.5,
cutoffs.at = c(.99,.9,.7,.6,.5,.4,.1,.01)) +
labs(title = "ROC Curve for Test Data",x = "False Positive Fraction",
y= "True Positive Fraction")
calc_auc(train_ROC)
calc_auc(test_ROC)
steam_train$pred_class <- ifelse(steam_train$logit_preds >.04,1,0)
steam_test$pred_class <-ifelse(steam_test$logit_preds>.04,1,0)
set.seed(2019)
train_index <- sample(1:nrow(steam),.75*nrow(steam),replace = FALSE)
steam_train <- steam[train_index,]
steam_test <- steam[-train_index,]
steam_logit <- glm(successfulGame~price+relevel(genres,ref = "Other") + required_age+
average_playtime,
data = steam_train,
family = "binomial")
steam_train$logit_preds <- predict(steam_logit,type = "response")
steam_test$logit_preds <- predict(steam_logit,newdata = steam_test,
type = "response")
steam_train$pred_class <- ifelse(steam_train$logit_preds >.04,1,0)
steam_test$pred_class <-ifelse(steam_test$logit_preds>.04,1,0)
train_ROC <- ggplot(steam_train,aes(m = logit_preds,
d = successfulGame)) +
geom_roc(labelsize = 3.5,
cutoffs.at = c(.99,.9,.7,.6,.5,.4,.1,.01)) +
labs(title = "ROC Curve for Train Data",x = "False Positive Fraction",
y= "True Positive Fraction")
test_ROC <- ggplot(steam_test,aes(m = logit_preds,
d = successfulGame)) +
geom_roc(labelsize = 3.5,
cutoffs.at = c(.99,.9,.7,.6,.5,.4,.1,.01)) +
labs(title = "ROC Curve for Test Data",x = "False Positive Fraction",
y= "True Positive Fraction")
train_ROC
ttest_ROC
train_ROC <- ggplot(steam_train,aes(m = logit_preds,
d = successfulGame)) +
geom_roc(labelsize = 3.5,
cutoffs.at = c(.99,.9,.7,.6,.5,.4,.1,.01)) +
labs(title = "ROC Curve for Train Data",x = "False Positive Fraction",
y= "True Positive Fraction")
test_ROC <- ggplot(steam_test,aes(m = logit_preds,
d = successfulGame)) +
geom_roc(labelsize = 3.5,
cutoffs.at = c(.99,.9,.7,.6,.5,.4,.1,.01)) +
labs(title = "ROC Curve for Test Data",x = "False Positive Fraction",
y= "True Positive Fraction")
train_ROC
test_ROC
steam$successfulGame <- as.factor(steam$successfulGame)
set.seed(2019)
train_idx <- sample(1:nrow(steam), size = floor(.75 * nrow(steam)))
steam_train <- steam[train_idx,]
steam_test <- steam[-train_idx,]
random_forest_steam <- randomForest(successfulGame~.,
data = steam_train,
mtry = 2,
ntrees = 500,
type = classification,
importance = TRUE)
random_forest_preds <- predict(random_forest_steam,type = "response")
preds_2 <- data.frame(steam_train,preds= random_forest_preds)
preds_test_2 <-data.frame(steam_test,preds = predict(random_forest_steam,
newdata = steam_test,
type = "response"))
importance(random_forest_steam)
plot(random_forest_steam)
varImpPlot(random_forest_steam)
plot(random_forest_steam)
varImpPlot(random_forest_steam)
#explain_forest(random_forest_steam)
#importance check
importance(random_forest_steam)
steam$successfulGame <- as.factor(steam$successfulGame)
set.seed(2019)
train_idx <- sample(1:nrow(steam), size = floor(.75 * nrow(steam)))
steam_train <- steam[train_idx,]
steam_test <- steam[-train_idx,]
###tree based on the top 4 most important variables
steam_tree <- tree(successfulGame~.,
data = steam_train)
plot(steam_tree)
text(steam_tree,pretty = 0)
steam$successfulGame <- as.factor(steam$successfulGame)
set.seed(2019)
train_idx <- sample(1:nrow(steam), size = floor(.75 * nrow(steam)))
steam_train <- steam[train_idx,]
steam_test <- steam[-train_idx,]
###tree based on the top 4 most important variables
steam_tree <- tree(successfulGame~.,
data = steam_train)
plot(steam_tree)
text(steam_tree,pretty = 0)
basic_preds_train <- data.frame(steam_train,preds = predict(pruned_tree,
type = "class"))
steam$successfulGame <- as.factor(steam$successfulGame)
set.seed(2019)
train_idx <- sample(1:nrow(steam), size = floor(.75 * nrow(steam)))
steam_train <- steam[train_idx,]
steam_test <- steam[-train_idx,]
###tree based on the top 4 most important variables
steam_tree <- tree(successfulGame~.,
data = steam_train)
###cross validation
tree_cv <- cv.tree(steam_tree)
best_tree_index <- which.min(tree_cv$dev)
best_size <- tree_cv$size[best_tree_index]
####prune the tree
pruned_tree <- prune.tree(steam_tree,best = best_size)
plot(pruned_tree)
text(pruned_tree,pretty=0)
basic_preds_train <- data.frame(steam_train,preds = predict(pruned_tree,
type = "class"))
basic_preds_test <- data.frame(steam_test,preds = predict(pruned_tree,
newdata = steam_test,
type = "class"))
###for train
CrossTable(basic_preds_train$successfulGame,basic_preds_train$preds,
prop.r = FALSE,
prop.c = FALSE,
prop.t = FALSE,
prop.chisq = FALSE)
###for test
CrossTable(basic_preds_test$successfulGame, basic_preds_test$preds,
prop.r = FALSE,
prop.c = FALSE,
prop.t = FALSE,
prop.chisq = FALSE)
