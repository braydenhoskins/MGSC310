steam$categories <- do.call('rbind',strsplit(as.character(steam$categories), ';', fixed=TRUE))[,1]
###turn them all into factors
steam$categories <- as.factor(steam$categories)
steam$genres <- as.factor(steam$genres)
###removing outliers
steam <- steam[steam$average_playtime < 100000,]
steam <- steam[steam$price <50,]
steam <- steam[steam$average_playtime < 40000,]
steam <- steam[steam$negative_ratings < 2e+05,]
steam <- steam[steam$positive_ratings < 1e+06,]
# Creating Groups of factored variables
library(forcats)
library(tidyverse)
fct_count(steam$categories)
steam %>%
mutate(categories = fct_lump(categories, n =5))%>%
count(categories)
###one way to do it
steam$simple_categories <- fct_lump(steam$categories,n = 4)
steam$categories <- ifelse(steam$categories == "Single-player","SinglePlayer",
ifelse(steam$categories == "Multi-player","Multi-Player",
ifelse(steam$categories == "Online Multi-Player","Multi-Player",
ifelse(steam$categories == "Local Multi-Player","Multi-Player",
ifelse(steam$categories == "MMO","MMO",
ifelse(steam$categories == "Co-op","Co-op",
ifelse(steam$categories == "Shared/Split Screen","Co-op",
ifelse(steam$categories == "Local Co-op","Co-op",
ifelse(steam$categories == "Online Co-op","Co-op",
ifelse(steam$categories == "Steam Cloud","Steam",
ifelse(steam$categories == "Steam Trading Cards","Steam",
ifelse(steam$categories == "Steam Leaderboards","Steam",
ifelse(steam$categories == "Steam Achievements","Steam","Other")))))))))))))
steam$categories <- as.factor(steam$categories)
unique(steam$categories)
unique(steam$categories)
###reducing the number of genres
steam$genres <- fct_lump(steam$genres,n = 5)
unique(steam$genres)
###creates variable successful game to help predict by (I was thinking we could
#use this as our predicted variable)(1 is a successful game - over 1 million sold,0 is anything less)
steam$successfulGame <- ifelse(steam$owners == "10000000-20000000",1,
ifelse(steam$owners == "20000000-50000000",1,
ifelse(steam$owners == "50000000-100000000",1,
ifelse(steam$owners == "100000000-200000000",1,
ifelse(steam$owners == "5000000-10000000",1,
ifelse(steam$owners == "2000000-5000000",1,
ifelse(steam$owners == "1000000-2000000",1,0)))))))
steam$successfulGame <- as.factor(steam$successfulGame)
steam <- subset(steam, select = -c(owners,categories))
library(glmnet)
library(glmnetUtils)
steam_lasso <- cv.glmnet(successfulGame~.,
data = steam,
alpha = 1,
family = "binomial")
coeff(steam_lasso)
coef(steam_lasso)
coef(steam_lasso$lambda.1se)
steam_lasso$lambda.1se
steam_lasso$lambda.min
plot(steam_lasso)
####regsubsets
library(leaps)
dim(steam)
?regsubsets
steam_fwd <- regsubsets(successfulGame~.,
data = steam,
nvmax = 9,
method = "forward",
family = "binomial")
steam_fwd <- regsubsets(successfulGame~.,
data = steam,
nvmax = 9,
method = "forward")
steam_fwd
summary(steam_fwd)
plot(steam_fwd)
steam_reg_subsets <- regsubsets(successfulGame~.,
data = steam,
nvmax = 8)
summary(steam_reg_subsets)
plot(steam_reg_subsets)
plot(steam_fwd,scaele = "adjr2")
plot(steam_reg_subsets,scale = "adjr2")
####dimensionality reduction
####Dont run this, it takes too long, we need to use other dimensionality reduction techniques
library(glmnet)
library(glmnetUtils)
?cv.glmnet
whic.max(summary(steam_fwd)$adjr2)
which.max(summary(steam_fwd)$adjr2)
which.max(summary(steam_reg_subsets)$adjr2)
#####
steam_logit <- glm(successfulGame~.,
data = steam,
family = "binomial")
coef(steam_lasso)
coef(steam_logit)
#####
set.seed(2019)
train_index <- sample(1:nrow(steam),.75*nrow(steam),replace = FALSE)
steam_train <- steam[train_index,]
steam_test <- steam[-train_index,]
steam_logit <- glm(successfulGame~.,
data = steam_train,
family = "binomial")
coef(steam_logit)
set.seed(2019)
train_index <- sample(1:nrow(steam),.75*nrow(steam),replace = FALSE)
steam_train <- steam[train_index,]
steam_test <- steam[-train_index,]
steam_logit <- glm(successfulGame~.,
data = steam_train,
family = "binomial")
preds_LOOCV = NULL;
for(i in 1:nrow(movies_train)){
mod <- glm(successfulGame~., family = binomial,
data = steam_train[-i,])
preds_LOOCV[i] <- predict(mod,newdata = steam_test[i,],type = "response")
}
head(preds_LOOCV)
preds_train <- data.frame(preds_train,loocvPreds = preds_LOOCV)
preds_LOOCV = NULL;
for(i in 1:nrow(steam_train)){
mod <- glm(successfulGame~., family = binomial,
data = steam_train[-i,])
preds_LOOCV[i] <- predict(mod,newdata = steam_test[i,],type = "response")
}
head(preds_LOOCV)
preds_train <- data.frame(preds_train,loocvPreds = preds_LOOCV)
preds_train <- data.frame(steam_train,predict(steam_logit,type = "response"))
preds_test <- data.frame(steam_test,predict(steam_logit,newdata = steam_test,
type = "response"))
preds_train <- data.frame(preds_train,loocvPreds = preds_LOOCV)
dim(steam_train)
dim(steam_test)
steam_logit <- glm(successfulGame~.,
data = steam_train,
family = "binomial")
preds_train <- data.frame(steam_train,predict(steam_logit,type = "response"))
preds_train
dim(preds_train)
preds_test
dim(preds_LOOCV)
preds_LOOCV = NULL;
for(i in 1:nrow(steam_train)){
mod <- glm(successfulGame~., family = binomial,
data = steam_train[-i,])
preds_LOOCV[i] <- predict(mod,newdata = steam_test[i,],type = "response")
}
preds_train <- data.frame(steam_train,predictions = predict(steam_logit,type = "response"))
preds_test <- data.frame(steam_test,predictions = predict(steam_logit,newdata = steam_test,
type = "response"))
library(plotROC)
library(ggplot2)
inSampleROC <- ggplot(preds_train,aes(m = predictions,
d = successfulGame)) +
geom_roc(labelsize = 3.5,
cutoffs.at = c(.99,.9,.7,.6,.5,.4,.1,.01)) +
labs(title = "ROC Curve for In-Sample Predictions",x = "False Positive Fraction",
y= "True Positive Fraction")
testROC <- ggplot(preds_test,aes(m = predictions,
d = successfulGame)) +
geom_roc(labelsize = 3.5,
cutoffs.at = c(.99,.9,.7,.6,.5,.4,.1,.01)) +
labs(title = "ROC Curve for Test Predictions",x = "False Positive Fraction",
y= "True Positive Fraction")
inSampleROC
testROC
summary(steam_logit)
steam_logit <- glm(successfulGame~price+positive_ratings+
negative_ratings + genres + required_age,
data = steam_train,
family = "binomial")
steam_logit$converged
steam_logit$residuals
cor(steam)
preds_train <- data.frame(steam_train,predictions = predict(steam_logit,type = "response"))
preds_test <- data.frame(steam_test,predictions = predict(steam_logit,newdata = steam_test,
type = "response"))
preds_train[preds_train == 0]
preds_train[preds_train == 1,]
quick_preds <- predict(steam_logit,type = "response")
quick_preds[quick_preds == 1,]
quick_preds[quick_preds == 1]
quick_preds[quick_preds == 0]
table(quick_preds)
steam_logit <- glm(successfulGame~price+positive_ratings+
negative_ratings + genres + required_age,
data = steam_train,
family = "binomial")
price
steam_logit <- glm(successfulGame~positive_ratings+
negative_ratings + genres + required_age,
data = steam_train,
family = "binomial")
steam_logit <- glm(successfulGame~price+
negative_ratings + genres + required_age,
data = steam_train,
family = "binomial")
steam_logit <- glm(successfulGame~price+positive_ratings+
+ genres + required_age,
data = steam_train,
family = "binomial")
steam_logit <- glm(successfulGame~price+positive_ratings+
negative_ratings + required_age,
data = steam_train,
family = "binomial")
steam_logit <- glm(successfulGame~price+positive_ratings+
negative_ratings + genres ,
data = steam_train,
family = "binomial")
steam_logit <- glm(successfulGame~price+positive_ratings+
negative_ratings + genres + factor(required_age),
data = steam_train,
family = "binomial")
unique(steam$required_age)
steam_logit <- glm(successfulGame~price+positive_ratings+
negative_ratings + genres + factor(required_age),
data = steam_train,
family = "binomial")
steam_logit <- glm(successfulGame~price+positive_ratings+
negative_ratings + factor(genres) + factor(required_age),
data = steam_train,
family = "binomial")
steam_logit <- glm(successfulGame~price+positive_ratings+
negative_ratings + factor(genres) + factor(required_age),
data = steam_train,
family = "binomial")
summary(steam_logit)
preds_train <- data.frame(steam_train,predictions = predict(steam_logit,type = "response"))
preds_test <- data.frame(steam_test,predictions = predict(steam_logit,newdata = steam_test,
type = "response"))
inSampleROC <- ggplot(preds_train,aes(m = predictions,
d = successfulGame)) +
geom_roc(labelsize = 3.5,
cutoffs.at = c(.99,.9,.7,.6,.5,.4,.1,.01)) +
labs(title = "ROC Curve for In-Sample Predictions",x = "False Positive Fraction",
y= "True Positive Fraction")
inSampleROC
set.seed(2019)
train_idx <- sample(1:nrow(steam), size = floor(.75 * nrow(steam)))
steam_train <- steam[train_idx,]
steam_test <- steam[-train_idx,]
library(randomForest)
rf_mods <- list()
oob_err <- NULL##to store out of bag error
test_err <- NULL
for(mtry in 1:9){
rf_fit <- randomForest(successfulGame~.,
data = steam_train,
mtry = mtry,
ntrees = 500,
type = classification)
oob_err[mtry] <- rf_fit$err.rate[500]
}
results_df <- data.frame(mtry = 1:9,
oob_err)
ggplot(results_df,aes(x = mtry,y = oob_err)) + geom_point() +geom_line()
boxplot(steam$average_playtime~steam$required_age,
main = "Average Playtime by Required Age",xlab = "Required Age (years)",
ylab = "Average Playtime")
str(steam)
steam$required_ageq <- as.factor(steam$required_age)
<<<<<<< HEAD
###Summary Statistics R code by Noah Estrada-Rand, Brady Hoskins, Charles Filce
setwd("C:\\Users\\noahe\\Desktop\\MGSC310")
steam <- read.csv("steam.csv")
#####exploratory data analysis
###there are no rows with missing values
nrow(steam[!complete.cases(steam),])
###variable engineering/cleaning
#steam$pos_rating_ratio <- steam$positive_ratings/steam$negative_ratings
##turns the unites into dollars
steam$price <- steam$price *1.28
####got rid of cariables that wont really help us
steam<- subset(steam, select = -c(appid,english,steamspy_tags,
name,release_date,
platforms,publisher,developer))
####I got rid of all the ';' delimited variables and instead assigned them a single value for that columne
steam$genres <- do.call('rbind',strsplit(as.character(steam$genres), ';', fixed=TRUE))[,1]
steam$categories <- do.call('rbind',strsplit(as.character(steam$categories), ';', fixed=TRUE))[,1]
###turn them all into factors
steam$categories <- as.factor(steam$categories)
steam$genres <- as.factor(steam$genres)
###removing outliers
steam <- steam[steam$average_playtime < 100000,]
steam <- steam[steam$price <50,]
steam <- steam[steam$average_playtime < 40000,]
steam <- steam[steam$negative_ratings < 2e+05,]
steam <- steam[steam$positive_ratings < 1e+06,]
# Creating Groups of factored variables
library(forcats)
library(tidyverse)
fct_count(steam$categories)
steam %>%
mutate(categories = fct_lump(categories, n =5))%>%
count(categories)
###one way to do it
steam$simple_categories <- fct_lump(steam$categories,n = 4)
steam$categories <- ifelse(steam$categories == "Single-player","SinglePlayer",
ifelse(steam$categories == "Multi-player","Multi-Player",
ifelse(steam$categories == "Online Multi-Player","Multi-Player",
ifelse(steam$categories == "Local Multi-Player","Multi-Player",
ifelse(steam$categories == "MMO","MMO",
ifelse(steam$categories == "Co-op","Co-op",
ifelse(steam$categories == "Shared/Split Screen","Co-op",
ifelse(steam$categories == "Local Co-op","Co-op",
ifelse(steam$categories == "Online Co-op","Co-op",
ifelse(steam$categories == "Steam Cloud","Steam",
ifelse(steam$categories == "Steam Trading Cards","Steam",
ifelse(steam$categories == "Steam Leaderboards","Steam",
ifelse(steam$categories == "Steam Achievements","Steam","Other")))))))))))))
steam$categories <- as.factor(steam$categories)
unique(steam$categories)
unique(steam$categories)
###reducing the number of genres
steam$genres <- fct_lump(steam$genres,n = 5)
unique(steam$genres)
###creates variable successful game to help predict by (I was thinking we could
#use this as our predicted variable)(1 is a successful game - over 1 million sold,0 is anything less)
steam$successfulGame <- ifelse(steam$owners == "10000000-20000000",1,
ifelse(steam$owners == "20000000-50000000",1,
ifelse(steam$owners == "50000000-100000000",1,
ifelse(steam$owners == "100000000-200000000",1,
ifelse(steam$owners == "5000000-10000000",1,
ifelse(steam$owners == "2000000-5000000",1,
ifelse(steam$owners == "1000000-2000000",1,0)))))))
steam$successfulGame <- as.factor(steam$successfulGame)
steam <- subset(steam, select = -c(owners,categories))
steam$required_age <- as.factor(steam$required_age)
steam$required_age
library(summarytools)
descr(steam)
numeric_cols <- sapply(steam,is.numeric)
library(corrplot)
correlations <- cor(steam[,numeric_cols])
corrplot(correlations)
boxplot(steam$average_playtime~steam$required_age,
main = "Average Playtime by Required Age",xlab = "Required Age (years)",
ylab = "Average Playtime")
####### finding the best mtry to use
set.seed(2019)
train_idx <- sample(1:nrow(steam), size = floor(.75 * nrow(steam)))
steam_train <- steam[train_idx,]
steam_test <- steam[-train_idx,]
dim(steam)
####bagging for randomforest
steam_bagged <- randomForest(successfulGame~.,
data = steam_train,
mtry = 9,
ntrees = 500,
type = classification,
importance = TRUE)
bagged_preds <- predict(steam_bagged,type = "response")
bagged_preds
table(bagged_preds)
preds_train_bagged <- data.frame(steam_train,bagged_preds)
preds_train_bagged <- data.frame(steam_train,bag_preds = bagged_preds)
table(preds_train_bagged$successfulGame,preds_train_bagged$bag_preds)
bagged_preds
table(bagged_preds)
table(preds_train_bagged$successfulGame,preds_train_bagged$bag_preds)
library(gmodels)
CrossTable(preds_train_bagged$successfulGame,preds_train_bagged$bag_preds)
CrossTable(preds_train_bagged$successfulGame,preds_train_bagged$bag_preds,
prop.r = FALSE,
prop.c = FALSE,
prop.t = FALSE,
prop.chisq = FALSE)
random_forest_preds <- predict(random_forest_steam,type = "response")
random_forest_steam <- randomForest(successfulGame~.,
data = steam_train,
mtry = 4,
ntrees = 500,
type = classification,
importance = TRUE)
CrossTable(preds_2$successfulGame,preds_2$preds,
prop.r = FALSE,
prop.c = FALSE,
prop.t = FALSE,
prop.chisq = FALSE)
preds_2 <- data.frame(steam_train,preds= random_forest_preds)
CrossTable(preds_2$successfulGame,preds_2$preds,
prop.r = FALSE,
prop.c = FALSE,
prop.t = FALSE,
prop.chisq = FALSE)
random_forest_preds <- predict(random_forest_steam,type = "response")
preds_2 <- data.frame(steam_train,preds= random_forest_preds)
CrossTable(preds_2$successfulGame,preds_2$preds,
prop.r = FALSE,
prop.c = FALSE,
prop.t = FALSE,
prop.chisq = FALSE)
preds_test_bagged <-data.frame(steam_test,bag_preds = predict(steam_bagged,
newdata = steam_test,
type = "response"))
###test confusion matrix
CrossTable(preds_test_bagged$successfulGame,preds_test_bagged$bag_preds)
###test confusion matrix
CrossTable(preds_test_bagged$successfulGame,preds_test_bagged$bag_preds,
prop.r = FALSE,
prop.c = FALSE,
prop.t = FALSE,
prop.chisq = FALSE)
preds_test_2 <-data.frame(steam_test,preds = predict(random_forest_steam,
newdata = steam_test,
type = "response"))
#test confusion matrix
CrossTable(preds_test_2$successfulGame,preds_test_2$preds,
prop.r = FALSE,
prop.c = FALSE,
prop.t = FALSE,
prop.chisq = FALSE)
###boosted
library(gbm)
boost_mod <- gbm(successfulGame~.,
data= steam_train,
distribution = "bernoulli", ###use bernoulli for classification
n.trees = 5000,
interaction.depth = 4)
?gbm
summary(boost_mod)
boost_preds_train(steam_train,preds = predict(boost_mod,type = "response"))
boost_preds_train(steam_train,preds = predict(boost_mod,type = "response"))
boost_preds_train <-data.frame(steam_train,preds = predict(boost_mod,type = "response"))
boost_preds_train <-data.frame(steam_train,preds = predict(boost_mod,type = "response",
n.trees = 500))
boost_preds_train <-data.frame(steam_train,preds = predict(boost_mod,type = "response",
n.trees = 5000))
boost_preds_test <-data.frame(steam_test,preds = predict(boost_mod,newdata = steam_test,
type = "response",
n.trees = 5000))
CrossTable(boost_preds_train$successfulGame,boost_preds_train$preds)
CrossTable(boost_preds_test$successfulGame,boost_preds_test$preds,
prop.r = FALSE,
prop.c = FALSE,
prop.t = FALSE,
prop.chisq = FALSE)
CrossTable(boost_preds_train$successfulGame,boost_preds_train$preds,
prop.r = FALSE,
prop.c = FALSE,
prop.t = FALSE,
prop.chisq = FALSE)
####dimensionality reduction
####Dont run this, it takes too long, we need to use other dimensionality reduction techniques
library(glmnet)
#importance check
importance(random_forest_steam)
plot(random_forest_steam)
text(random_forest_steam,pretty = 0)
varImpPlot(random_forest_steam)
###tree based on the top 4 most important variables
library(tree)
steam_tree <- tree(successfulGame~positive_ratings +
price + achievements + negative_ratings,
data = steam_train)
plot(steam_tree)
text(steam_tree,pretty = 0)
###performance
basic_preds_train <- data.frame(steam_train,preds = predict(steam_tree,
type = "response"))
steam_tree <- tree(successfulGame~positive_ratings +
price + achievements + negative_ratings,
data = steam_train)
plot(steam_tree)
text(steam_tree,pretty = 0)
###performance
basic_preds_train <- data.frame(steam_train,preds = predict(steam_tree,
type = "response"))
###performance
basic_preds_train <- data.frame(steam_train,preds = predict(steam_tree,
newdata = steam_test,
type = "response"))
predict(steam_tree,type = "response")
predict(steam_tree)
steam_tree <- tree(successfulGame~positive_ratings +
price + achievements + negative_ratings,
data = steam_train,
type = classification)
?tree
steam_tree <- tree(successfulGame~positive_ratings +
price + achievements + negative_ratings,
data = steam_train,
type = "classification")
steam_tree <- tree(successfulGame~positive_ratings +
price + achievements + negative_ratings,
data = steam_train,
method = "class")
predict(steam_tree)
###performance
basic_preds_train <- data.frame(steam_train,preds = predict(steam_tree,
type = "class"))
basic_preds_test <- data.frame(steam_test,preds = predict(steam_tree,
newdata = steam_test,
type = "class"))
CrossTable(basic_preds_train$successfulGame,basic_preds_train$preds,
prop.r = FALSE,
prop.c = FALSE,
prop.t = FALSE,
prop.chisq = FALSE)
CrossTable(basic_preds_test$successfulGame, basic_preds_test$preds,
prop.r = FALSE,
prop.c = FALSE,
prop.t = FALSE,
prop.chisq = FALSE)
CrossTable(basic_preds_train$successfulGame,basic_preds_train$preds,
prop.r = FALSE,
prop.c = FALSE,
prop.t = FALSE,
prop.chisq = FALSE)
